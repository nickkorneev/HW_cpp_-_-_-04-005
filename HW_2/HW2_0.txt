1)
 std::pair и std::tuple удобны, если функция возвращает несколько значений разных типов.
 Класс pair интерпретирует два значения как одно целое. Можно обрабатывать значения,
 являющиеся элементами класса pair. Класс Tuple используется для выяснения количества элементов,
 для распознавания типа какого-нибудь элемента, для доступа к элементам.
 Шаблонная функция make_pair позволяет создавать пары значений, не указывая типы элементов явно.
 Шаблонная функция make_tuple позволяет создать кортеж значений без явного указания их типов.

2)
 std::array удобен для работы с последовательностью из фиксированного числа элементов.
 Так как память для него выделяется на стеке, это ускоряет работу,
 нет дополнительных выделений памяти и существует прямой доступ к элементам по индексу.

3)
 std::vector - управляет элементами которые хранятся в динамическим массиве, обеспечивает доступ к элементу за константное время.
 Высокопроизводительны при вставке и удалении в конце. Вывод: если нужен динамический массив со вставкой преимущественно в конец - используй вектор.

4)
 std::deque - динамический массив, который может расти и в начале, и в конце.
 Страничная структура памяти. Высокопроизводителен при вставке и в начало, и в конец.
 Лучше не ссылаться на элементы контейнера, т.к. будет допольнительный расход памяти из-за страничной реализации.

5)
 std::list - двусвязный список. Не предоставляет произвольный доступ к элементам(проходы по цепочке, согласно указателям на соседние элементы).
 Вставка и удаление за константное время из любой позиции в контейнере. Все указатели, ссылки, итераторы остаются корректными после удаления элемента.
 Итераторы двунаправленные.

6)
 std::forward_list - односвязный список. Не предоставяляет произвольный доступ к элементам,
 проход по цепочке (однонаправленный итератор). Вставка и удаление за константное время из любой позиции контейнера
 (т.к. не надо переприсваивать значения остальных элементов). Все указатели, ссылки, итераторы остаются корректными после удаления элемента.
 Экономнее по памяти по сравнению с list

7)
 Адаптеры: stack управляет по принципу - последним вошел, первым вышел (LIFO); queue - первым вошел, первым вышел(FIFO);
 priority_queue - как очередь, только дополнительно сортирует элементы, сортировка задается программистом (FIFO + sort).

8)
 Если объём доступной памяти ограничен, и нужно предотвратить произвольный рост контейнера.
 Или если идет непрерывный поток данных, и старые данные становятся ненужными по мере появления новых.
 Память автоматически используется повторно путем перезаписи старых данных.

9)
 Элемент, который добавлен позже по времени, может стоять в памяти левее, чем более ранний,
 потому что это круговой контейнер, что противоречит концепции стандартной библиотеки.

10)
 Обычный двумерный массив, вектор векторов, std::valarray представим как многомерный массив, Boost.Multi_array.